## DAY 16
- [x] calculate jumps to target
- [x] fix jump calculation
- each BFS has to have it's own map of visited nodes - it cannot be shared
  - [x] fix BFS test - make BFS use the visited map and not the visited property on the object
  - [x] remove visited property on the Valve object 
- [x] figure out a more elegant way of passing a map of visited nodes to BFS function, at the moment we create a fresh copy when starting a root invocation - this is not  a sustainable practice
- [x] calculate expected returns from all nodes based on current location
- [x] run 30 turn, recalculating with each move
- test the calculate_returns ( pay attention to case where you run out of turns )
  - [x] current test iterates over the empty node? examine that
  - [x] break up the function, or add comments, its difficult to reason about it
- improve the calculate_returns algo - it is not returning max possible value, perhaps we can run different scenarios where we do look ahead ( sum of two next moves etc )
  - [x] extract the loop outside, pass in the maps as params, and return them after each run?
  - [x] return a list of tuples ordered by potential returns
  - [x] return number of turns remaining with the tuple in function test_calculate_returns3_two_jumps
  - [x] manually verify that the test test_different_paths gives correct results 
  - [x] create a function that incorporates the above ( gets initials paths and then calculates returns for all subsequent paths and spits out the results )
    - [x] make the function take a number of top paths to retain, and explore their total returns.
    - [x] when we calculate returns for various paths, we need to be able to keep track of the path already taken ( start position and subsequent steps )
  - [x] use single step function to calculate returns for all possible routes
  - fix total_flow calculation
  - use step function in a loop or recursion
    - handle the 'out of turns' use case
    - perhaps we can prune recursive branches when they reach a limit - say 10k calls?
