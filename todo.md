## DAY 16
- [x] calculate jumps to target
- [x] fix jump calculation
- each BFS has to have it's own map of visited nodes - it cannot be shared
  - [x] fix BFS test - make BFS use the visited map and not the visited property on the object
  - [x] remove visited property on the Valve object 
- [x] figure out a more elegant way of passing a map of visited nodes to BFS function, at the moment we create a fresh copy when starting a root invocation - this is not  a sustainable practice
- [x] calculate expected returns from all nodes based on current location
- [x] run 30 turn, recalculating with each move
- test the calculate_returns ( pay attention to case where you run out of turns )
  - [x] current test iterates over the empty node? examine that
  - [x] break up the function, or add comments, its difficult to reason about it
- improve the calculate_returns algo - it is not returning max possible value, perhaps we can run different scenarios where we do look ahead ( sum of two next moves etc )
  - [x] extract the loop outside, pass in the maps as params, and return them after each run?
  - [x] return a list of tuples ordered by potential returns
  - [x] add Valve_Exprected_Returns
  - return number of turns remaining with the tuple in function test_calculate_returns3_two_jumps
  - when you have all that info, you can then select aribrary number of top results and plug them into version 2 ? to get max results? worth a try
